// Explicator_Module_Subsequence.cc - DICOMautomaton, 2012.
//
// For each family of dirties corresponding to a unique clean, a list of ordered subsequences
// with length N where N = [L,U] (which are unique to the clean) are generated by exhaustive search.
//
// Upon receiving a query, the same procedure is performed. The query is compared with the
// list to see how many matches (and maybe non-matches) are present. The most matches is probably
// best, but some normalization should be performed.

#include <algorithm>
#include <iterator>
#include <map>
#include <memory>
#include <set>
#include <string>
#include <utility>

#include "Misc.h"
#include "String.h"

static const long int L = 2; // Minimum subsequence length.
static const long int U = 6; // Maximum subsequence length.

static std::map<std::string, std::set<std::string>> subseq_lexicon; // clean -> set of subsequences.
static std::set<std::string> common_subseqs;                        // A list of common subsequences which are omitted.

static float max_set_size = -1.0;

// Initializor function.
void Explicator_Module_Subsequence_Init(const std::map<std::string, std::string> &lexicon,
                                        float threshold) { // The lexicon looks like: < dirty : clean >.
    subseq_lexicon.clear();
    if(lexicon.empty()) {
        return; // Should we FUNCERR instead?
    }

    // Populate the subseq_lexicon with *all* subsequences. This is slow, wasteful, and very easy to code.
    for(auto it = lexicon.begin(); it != lexicon.end(); ++it) {
        const std::string dirty
            = Canonicalize_String2(it->first, CANONICALIZE::TRIM_ALL | CANONICALIZE::TO_UPPER); // Remove ALL spaces.
        const std::string clean(it->second);

        std::set<std::string> allsubsequences;
        for(long int N = L; N <= U; ++N) {
            const auto subseqs = NGrams(dirty, -1, N, NGRAMS::CHARS);
            allsubsequences.insert(subseqs.begin(), subseqs.end());
        }
        subseq_lexicon[clean].insert(allsubsequences.begin(), allsubsequences.end());
    }

    if(subseq_lexicon.size() == 1) {
        return; // No duplicates. Not ideal, but useable. No need to go on.
    }

    // Now cycle through the suqsequences and remove all which are duplicated somewhere.
    for(auto it1 = ++(subseq_lexicon.begin()); it1 != subseq_lexicon.end(); ++it1) {
        for(auto it2 = subseq_lexicon.begin(); (it2 != subseq_lexicon.end()) && (it2 != it1); ++it2) {
            // Find the subsequences which appear in both.
            std::set<std::string> intersection;
            std::set_intersection(it1->second.begin(), it1->second.end(), it2->second.begin(), it2->second.end(),
                                  std::inserter(intersection, intersection.begin()));

            common_subseqs.insert(intersection.begin(), intersection.end());

            // Remove the matching subsequences from both sets.
            {
                std::set<std::string> diff;
                std::set_difference(it1->second.begin(), it1->second.end(), common_subseqs.begin(),
                                    common_subseqs.end(), std::inserter(diff, diff.begin()));
                it1->second = diff;
            }
            {
                std::set<std::string> diff;
                std::set_difference(it2->second.begin(), it2->second.end(), common_subseqs.begin(),
                                    common_subseqs.end(), std::inserter(diff, diff.begin()));
                it2->second = diff;
            }
        }
    }

    // Find the largest and smallest set size.
    const auto lambda_lt = [](const std::pair<std::string, std::set<std::string>> &A,
                              const std::pair<std::string, std::set<std::string>> &B) -> bool {
        return A.second.size() < B.second.size();
    };
    max_set_size = static_cast<float>(
        (std::max_element(subseq_lexicon.begin(), subseq_lexicon.end(), lambda_lt))->second.size());
}

// Query function.
std::unique_ptr<std::map<std::string, float>>
Explicator_Module_Subsequence_Query(const std::map<std::string, std::string> &lexicon,
                                    const std::string &in,
                                    float threshold) {
    // Remember: The lexicon looks like: < dirty : clean >
    std::unique_ptr<std::map<std::string, float>> output(new std::map<std::string, float>());

    const std::string dirty
        = Canonicalize_String2(in, CANONICALIZE::TRIM_ALL | CANONICALIZE::TO_UPPER); // Remove ALL spaces.

    // Find all the subsequences in this string.
    std::set<std::string> in_subseqs;
    for(long int N = L; N <= U; ++N) {
        const auto subseqs = NGrams(dirty, -1, N, NGRAMS::CHARS);
        in_subseqs.insert(subseqs.begin(), subseqs.end());
    }

    // Remove common subsequences. If nothing remains, jump ship!
    std::set<std::string> diff;
    std::set_difference(in_subseqs.begin(), in_subseqs.end(), common_subseqs.begin(), common_subseqs.end(),
                        std::inserter(diff, diff.begin()));
    in_subseqs = diff;
    if(in_subseqs.empty()) {
        return std::move(output);
    }

    const float theobest = static_cast<float>(
        in_subseqs.size()); // This might also be watered down unnecessarily due to common subsequences...
    const float theoworst = 0.0;

    if(theobest <= theoworst) {
        FUNCWARN("The theoretical maximum score is <= theoretical minimum - unable to compute anything meaningful");
        FUNCWARN("    (This is a module limitation. Lexicons which are too large or homogeneous may not be suitable!)");
        return std::move(output);
    }

    // Cycle over the list of unique subsequences. Do not penalize for extra subsequences in the input, because they may
    // have
    // occured in the lexicon but were removed because they were not unique to the specific clean.
    for(auto it = subseq_lexicon.begin(); it != subseq_lexicon.end(); ++it) {
        const std::string clean(it->first);
        std::set<std::string> intersection;
        std::set_intersection(it->second.begin(), it->second.end(), in_subseqs.begin(), in_subseqs.end(),
                              std::inserter(intersection, intersection.begin()));

        const float matches = static_cast<float>(intersection.size());
        const float scaled  = (matches - theoworst) / (theobest - theoworst);

        if((scaled > threshold)
           && (!(output->find(clean) != output->end()) || ((*output)[clean] < scaled))) { // If this score is higher.
            (*output)[clean] = scaled;
            // Do not break on an exact match. This is not a very exact module and this is detrimental to mixing with
            // other modules.
            // if(score == theobest) break; //This is an exact match - no need to look further.
        }
    }
    return std::move(output);
}

// De-initializor function. Ensure this function can be called both after AND before the init function.
void Explicator_Module_Subsequence_Deinit(void) {
    subseq_lexicon.clear();
    common_subseqs.clear();
    max_set_size = -1.0;
}
