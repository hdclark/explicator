// Cross_Verify.cc - A program which attempts to quantify the fraction of all queries we incorrectly assume to be valid.
//
// It takes a fraction of the lexicon, attempts to translate entries from the complete lexicon, and determines whether
// or not the translation was successful by comparing the output to the actual value.

#include <iostream>
#include <stdexcept>
#include <string>
#include <tuple>

#include "Explicator.h"

int main(int argc, char **argv) {
    if(argc != 2) {
        throw std::runtime_error("Please provide a lexicon filename.");
    }
    const std::string filename(argv[1]);

    Explicator X(filename);

    const bool beverbose = false;

    // Note: altering various weights, thresholds, and mixing and matching modules will alter performance. If you are
    // having problems with, say, false positives, you shold try altering these factors right here and seeing how
    // cross-verification is affected. (There is another example program demonstrating how to do this.)

    std::cout << "# Generated by Cross_Verify(...)." << std::endl;
    std::cout << "# Columns: lexicon_threshold(%), frac_of_lexicon(%), frac_correct, frac_false_neg, frac_false_pos, "
                 "frac_theo_best."
              << std::endl;
    std::cout << "# Each column is a fraction of the total number of translations." << std::endl;
    for(long int t = 100; t >= 5; t -= 5) {     // Threshold, percent.
        for(long int f = 100; f >= 5; f -= 5) { // Lexicon fraction, percent.
            const float frac      = static_cast<float>(f) / 100.0;
            const float threshold = static_cast<float>(t) / 100.0;

            X.group_threshold = threshold;
            const auto res = X.Cross_Verify(frac, 5, beverbose);
            std::cout << t << " " << f << " " << std::get<0>(res) << " " << std::get<2>(res) << " " << std::get<3>(res)
                      << " " << std::get<1>(res) << std::endl;
        }
    }

    return 0;
}
